# Symfony Messenger Integration: CQRS and Async Message Processing

API Platform provides an integration with the [Symfony Messenger Component](https://symfony.com/doc/current/messenger.html).

This feature allows to implement the [Command Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) pattern in a convenient way.
It also makes it easy to send messages through the web API that will be consumed asynchronously.

Many transports are supported to dispatch messages to async consumers, including RabbitMQ, Apache Kafka, Amazon SQS and Google Pub/Sub.

## Installing Symfony Messenger

To enable the support of Messenger, install the library:

     $ docker-compose exec php composer require messenger

## Dispatching a Resource through the Message Bus

Set the `messenger` attribute to `true`, and API Platform will automatically dispatch the API Resource instance as a message using the message bus provided by the Messenger Component:

```php
<?php

// api/src/Entity/Book.php

namespace App\Entity;

use ApiPlatform\Core\Annotation\ApiResource;
use Symfony\Component\Validator\Constraints as Assert;

/**
 * @ApiResource(
 *     collectionOperations={
 *         "output"=false,
 *         "post"={"status"=202}
 *     },
 *     messenger=true,
 * )
 */
final class Book
{
    /**
     * @var string
     *
     * @Assert\NotBlank
     */
    public title;
}
```

Alternatively, you can use the YAML configuration format:

```yaml
# api/config/api_platform/resources.yaml
resources:
  App\Entity\Book:
    attributes:
        messenger: true
    collectionOperations:
      post:
        output: false
        status: 202
```

Because the `messenger` attribute is `true`, when a write operation (`PUT`, `DELETE`, `POST`) is handled by API Platform, the corresponding instance of the `Book` will be dispatched.

For the `POST` operation here, We use the `status` attribute to configure API Platform to return a [202 Accepted HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/202).
It indicates that the request has been received and will be treated later, without giving an immediate return to the client.
Finally, the `output` attribute is set to `false`, so the HTTP response that will be generated by API Platform will be empty, and the [serialization process](serialization.md) will be skipped.

## Registering a Message Handler

To process the message that will be dispatched, [a handler](https://symfony.com/doc/current/messenger.html#registering-handlers) must be created:

```php
<?php

// api/src/Handler/BookHandler.php

namespace App\Handler;

use App\Entity\Book;
use Symfony\Component\Messenger\Handler\MessageHandlerInterface;

final class BookHandler implements MessageHandlerInterface
{
    public function __invoke(Book $book)
    {
        // do something with the resource
    }
}
```

That's all!

By default, the handler will process your message synchronously.
If you want it to be consumed asynchronously (e.g. by a worker machine), [configure a transport and the consumer](https://symfony.com/doc/current/messenger.html#transports).

## Accessing the Data Returned by the Handler

API Platform automatically uses the `Symfony\Component\Messenger\Stamp\HandledStamp` when set.
It means that if you use a synchronous handler, the data returned by the `__invoke` method replaces the original data.

## Detecting Removals

When a `DELETE` operation occurs, API Platform automatically adds a `ApiPlatform\Core\Bridge\Symfony\Messenger\RemoveStamp` ["stamp"](https://symfony.com/doc/current/components/messenger.html#adding-metadata-to-messages-envelopes) instance to the "envelope".
To differentiate typical persists calls (create and update) and removal calls, check for the presence of this stamp using [a custom "middleware"](https://symfony.com/doc/current/components/messenger.html#adding-metadata-to-messages-envelopes).

## Using Messenger with an Input Object

Set the `messenger` attribute to `input`, and API Platform will automatically dispatch the given Input as a message instead of the Resource. Indeed, it'll add a default `DataTransformer` ([see input/output documentation](./dto.md)) that handles the given `input`.

For this example, we're going to implement password reset requests via the User resource.

```php
<?php

// api/src/Entity/User.php

namespace App\Entity;

use ApiPlatform\Core\Annotation\ApiResource;
use App\Dto\PasswordResetRequest;

/**
 * @ApiResource(
 *     collectionOperations={
 *         "post",
 *         "get",
 *         "post_password_reset_request"={
 *             "method"="POST",
 *             "path"="/users/password_reset_request",
 *             "messenger"="input",
 *             "input"=PasswordResetRequest::class,
 *             "status"=202,
 *             "output"=false,
 *             "normalization_context"={
 *                 "groups"={"user_password_reset_request"},
 *             },
 *             "denormalization_context"={
 *                 "groups"={"user_password_reset_request"},
 *             },
 *         },
 *     }
 * )
 */
final class User
{
}
```

Where `PasswordResetRequest` would be:

```php
<?php

// api/src/Dto/PasswordResetRequest.php

namespace App\Dto;

use Symfony\Component\Serializer\Annotation\Groups;

final class PasswordResetRequest
{
    /**
     * @Groups({"user_password_reset_request"})
     */
    private $email;

    public function __construct(string $email = '')
    {
        $this->email = $email;
    }

    public function getEmail(): string
    {
        return $this->email;
    }
}
```

For the `POST` operation here, We use the `status` attribute to configure API Platform to return a [202 Accepted HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/202).
It indicates that the request has been received and will be treated later, without giving an immediate return to the client.
Finally, the `output` attribute is set to `false`, so the HTTP response that will be generated by API Platform will be empty, and the [serialization process](serialization.md) will be skipped.

In this case, when a `POST` request is issued on `/users/password_reset_request` the message handler will receive an `App\Dto\PasswordResetRequest` object instead a `User` because we specified it as `input` and set `messenger=input`:

```php
<?php

// api/src/Handler/PasswordResetRequestHandler.php

namespace App\Handler;

use App\Dto\PasswordResetRequest;

class PasswordResetRequestHandler implements MessageHandlerInterface
{
    public function __invoke(PasswordResetRequest $passwordResetRequest)
    {
        // send the email somehow using $passwordResetRequest->getEmail()
    }
}
```
