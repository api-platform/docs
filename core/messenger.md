# Symfony Messenger Integration: CQRS and Async Message Processing

API Platform provides an integration with the [Symfony Messenger Component](https://symfony.com/doc/current/messenger.html).

This feature allows to implement the [Command Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) pattern in a convenient way.
It also makes it easy to send messages through the web API that will be consumed asynchronously.

Many transports are supported to dispatch messages to async consumers, including RabbitMQ, Apache Kafka, Amazon SQS and Google Pub/Sub.

## Installing Symfony Messenger

To enable the support of Messenger, install the library:

     $ docker-compose exec php composer require messenger

## Dispatching a Resource through the Message Bus

Set the `messenger` attribute to `true`, and API Platform will automatically dispatch the API Resource instance as a message using the message bus provided by the Messenger Component:

```php
<?php

// api/src/Entity/Book.php

namespace App\Entity;

use ApiPlatform\Core\Annotation\ApiResource;
use Symfony\Component\Validator\Constraints as Assert;

/**
 * @ApiResource(
 *     collectionOperations={
 *         "post"={
 *             "status"=202,
 *             "output"=false,
 *             "messenger"=true,
 *         },
 *     },
 * )
 */
final class Book
{
    /**
     * @var string
     *
     * @Assert\NotBlank
     */
    public $title;
}
```

Alternatively, you can use the YAML configuration format:

```yaml
# api/config/api_platform/resources.yaml
resources:
  App\Entity\Book:
    attributes:
        messenger: true
    collectionOperations:
      post:
        output: false
        status: 202
```

Because the `messenger` attribute is `true`, when a write operation (`PUT`, `DELETE`, `POST`) is handled by API Platform, after [deserialization](serialization.md) the hydrated instance of the `Book` object will be dispatched to [the default message bus](https://symfony.com/doc/current/messenger.html#dispatching-the-message).

For the `POST` operation here, we use the `status` attribute to return a [202 Accepted HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/202) in case of success.
It indicates that the request has been received and will be treated later, without giving an immediate return to the client.
Finally, the `output` attribute is set to `false`, so the HTTP response that will be generated by API Platform will be empty, and the [serialization process](serialization.md) will be skipped.

### Registering a Message Handler

To process the message that will be dispatched, [a handler](https://symfony.com/doc/current/messenger.html#registering-handlers) must be created:

```php
<?php

// api/src/Handler/BookHandler.php

namespace App\Handler;

use App\Entity\Book;
use Symfony\Component\Messenger\Handler\MessageHandlerInterface;

final class BookHandler implements MessageHandlerInterface
{
    public function __invoke(Book $book)
    {
        // do something with the resource
    }
}
```

That's all!

By default, the handler will process your message synchronously.
If you want it to be consumed asynchronously (e.g. by a worker machine), [configure a transport and the consumer](https://symfony.com/doc/current/messenger.html#transports).

### Accessing the Data Returned by the Handler

API Platform automatically uses the `Symfony\Component\Messenger\Stamp\HandledStamp` when set.
It means that if you use a synchronous handler, the data returned by the `__invoke` method replaces the original data.

### Detecting Removals

When a `DELETE` operation occurs, API Platform automatically adds a `ApiPlatform\Core\Bridge\Symfony\Messenger\RemoveStamp` ["stamp"](https://symfony.com/doc/current/components/messenger.html#adding-metadata-to-messages-envelopes) instance to the "envelope".
To differentiate typical persists calls (create and update) and removal calls, check for the presence of this stamp using [a custom "middleware"](https://symfony.com/doc/current/components/messenger.html#adding-metadata-to-messages-envelopes).

### Working with Doctrine's Entity Manager

When using async handlers, by default the Messenger component uses the native `serialize()` PHP function to serialize the content of the payload to transfer to the handler. If you're using a Doctrine entity as a message, it will not be in sync with the Doctrine's Object Manager when received by the handler. You'll have [to merge the entity](https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/working-with-objects.html#merging-entities) manually.
Another solution is to switch the messenger's serializer to one supporting the format of your choice, for example:

```
framework:
    messenger:
        serializer:
            default_serializer: messenger.transport.symfony_serializer
            symfony_serializer:
                format: json
                context: { }
```

Note that when doing so it may have a negative impact on performances. Also, if API Platform's serializer is used, it will support only Resources not DTOs.

## Using Messenger with an Input Object

Set the `messenger` attribute to `input`, and API Platform will automatically dispatch the given Input as a message instead of the Resource. Indeed, it'll add a default `DataTransformer` ([see input/output documentation](./dto.md)) that handles the given `input`.

For this example, we're going to implement password reset requests via the User resource.

```php
<?php

// api/src/Entity/User.php

namespace App\Entity;

use ApiPlatform\Core\Annotation\ApiResource;
use App\Dto\PasswordResetRequest;

/**
 * @ApiResource(
 *     collectionOperations={
 *         "get",
 *         "post",
 *         "post_password_reset_request"={
 *             "method"="POST",
 *             "path"="/users/password_reset_request",
 *             "messenger"="input",
 *             "input"=PasswordResetRequest::class,
 *             "status"=202,
 *             "output"=false
 *         },
 *     }
 * )
 */
final class User
{
}
```

Where `PasswordResetRequest` would be:

```php
<?php

// api/src/Dto/PasswordResetRequest.php

namespace App\Dto;

final class PasswordResetRequest
{
    public $email;
}
```

For the `POST` operation here, we use the `status` attribute to return a [202 Accepted HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/202) in case of success.
It indicates that the request has been received and will be treated later, without giving an immediate return to the client.
Finally, the `output` attribute is set to `false`, so the HTTP response that will be generated by API Platform will be empty, and the [serialization process](serialization.md) will be skipped.

In this case, when a `POST` request is issued on `/users/password_reset_request` the message handler will receive an `App\Dto\PasswordResetRequest` object instead a `User` because we specified it as `input` and set `messenger=input`:

```php
<?php

// api/src/Handler/PasswordResetRequestHandler.php

namespace App\Handler;

use App\Dto\PasswordResetRequest;

class PasswordResetRequestHandler implements MessageHandlerInterface
{
    public function __invoke(PasswordResetRequest $passwordResetRequest)
    {
        // send the email somehow using $passwordResetRequest->getEmail()
    }
}
```
